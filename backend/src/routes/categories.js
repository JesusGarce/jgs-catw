import express from 'express';
import { PrismaClient } from '@prisma/client';
import { logger } from '../utils/logger.js';
import { AppError } from '../middleware/errorHandler.js';
import { 
  createAutoCategories, 
  recategorizeAllTweets, 
  getSuggestedCategories,
  initializeAI,
  categorizeUncategorizedTweets
} from '../services/categorizationService.js';

const router = express.Router();
const prisma = new PrismaClient();

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üõ†Ô∏è UTILIDADES Y HELPERS
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Verificar que la categor√≠a pertenece al usuario
 */
async function verifyCategoryOwnership(categoryId, userId) {
  const category = await prisma.category.findFirst({
    where: {
      id: parseInt(categoryId),
      userId
    }
  });

  if (!category) {
    throw new AppError('Categor√≠a no encontrada', 404, 'CATEGORY_NOT_FOUND');
  }

  return category;
}

/**
 * Obtener conteo de tweets por categor√≠a
 */
async function getCategoryTweetCount(categoryName, userId) {
  return await prisma.tweet.count({
    where: {
      userId,
      category: categoryName,
      isArchived: false
    }
  });
}

/**
 * GET /api/v1/categories
 * Obtener todas las categor√≠as del usuario
 */
router.get('/', async (req, res, next) => {
  try {
    const categories = await prisma.category.findMany({
      where: { userId: req.user.id },
      orderBy: { sortOrder: 'asc' }
    });

    // Obtener conteo de tweets por categor√≠a
    const categoriesWithCount = await Promise.all(
      categories.map(async (category) => {
        const tweetCount = await getCategoryTweetCount(category.name, req.user.id);
        return {
          ...category,
          tweetCount
        };
      })
    );

    res.json({ categories: categoriesWithCount });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/categories
 * Crear nueva categor√≠a
 */
router.post('/', async (req, res, next) => {
  try {
    const { name, description, color } = req.body;

    if (!name) {
      throw new AppError('Nombre de categor√≠a requerido', 400, 'MISSING_NAME');
    }

    // Verificar que no existe una categor√≠a con el mismo nombre
    const existingCategory = await prisma.category.findFirst({
      where: {
        userId: req.user.id,
        name: name.trim()
      }
    });

    if (existingCategory) {
      throw new AppError('Ya existe una categor√≠a con ese nombre', 400, 'CATEGORY_EXISTS');
    }

    // Obtener el pr√≥ximo sortOrder
    const lastCategory = await prisma.category.findFirst({
      where: { userId: req.user.id },
      orderBy: { sortOrder: 'desc' }
    });

    const sortOrder = (lastCategory?.sortOrder || 0) + 1;

    // Crear la categor√≠a
    const category = await prisma.category.create({
      data: {
        name: name.trim(),
        description: description?.trim() || null,
        color: color || '#6B7280', // Color por defecto (gris)
        userId: req.user.id,
        sortOrder,
        isDefault: false
      }
    });

    logger.info('Category created', {
      userId: req.user.id,
      categoryId: category.id,
      categoryName: category.name
    });

    res.status(201).json({
      success: true,
      category: {
        ...category,
        tweetCount: 0
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * PUT /api/v1/categories/:id
 * Actualizar categor√≠a existente
 */
router.put('/:id', async (req, res, next) => {
  try {
    const { id } = req.params;
    const { name, description, color, sortOrder } = req.body;

    const existingCategory = await verifyCategoryOwnership(id, req.user.id);

    // Si se est√° cambiando el nombre, verificar que no exista otra con el mismo nombre
    if (name && name.trim() !== existingCategory.name) {
      const duplicateCategory = await prisma.category.findFirst({
        where: {
          userId: req.user.id,
          name: name.trim(),
          id: { not: parseInt(id) }
        }
      });

      if (duplicateCategory) {
        throw new AppError('Ya existe una categor√≠a con ese nombre', 400, 'CATEGORY_EXISTS');
      }
    }

    // Preparar datos para actualizar
    const updateData = {};
    if (name) updateData.name = name.trim();
    if (description !== undefined) updateData.description = description?.trim() || null;
    if (color) updateData.color = color;
    if (sortOrder !== undefined) updateData.sortOrder = parseInt(sortOrder);

    // Actualizar categor√≠a
    const updatedCategory = await prisma.category.update({
      where: { id: parseInt(id) },
      data: updateData
    });

    // Si se cambi√≥ el nombre, actualizar tweets que usan esta categor√≠a
    if (name && name.trim() !== existingCategory.name) {
      await prisma.tweet.updateMany({
        where: {
          userId: req.user.id,
          category: existingCategory.name
        },
        data: {
          category: name.trim()
        }
      });

      logger.info('Category renamed, tweets updated', {
        userId: req.user.id,
        categoryId: updatedCategory.id,
        oldName: existingCategory.name,
        newName: name.trim()
      });
    }

    // Obtener conteo actualizado de tweets
    const tweetCount = await getCategoryTweetCount(updatedCategory.name, req.user.id);

    logger.info('Category updated', {
      userId: req.user.id,
      categoryId: updatedCategory.id,
      categoryName: updatedCategory.name
    });

    res.json({
      success: true,
      category: {
        ...updatedCategory,
        tweetCount
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * DELETE /api/v1/categories/:id
 * Eliminar categor√≠a (solo si no tiene tweets)
 */
router.delete('/:id', async (req, res, next) => {
  try {
    const { id } = req.params;
    const category = await verifyCategoryOwnership(id, req.user.id);

    // No permitir eliminar categor√≠a por defecto
    if (category.isDefault) {
      throw new AppError('No se puede eliminar la categor√≠a por defecto', 400, 'CANNOT_DELETE_DEFAULT');
    }

    // Verificar si tiene tweets asociados
    const tweetCount = await getCategoryTweetCount(category.name, req.user.id);

    if (tweetCount > 0) {
      throw new AppError(
        `No se puede eliminar la categor√≠a porque tiene ${tweetCount} tweets asociados`,
        400,
        'CATEGORY_HAS_TWEETS'
      );
    }

    // Eliminar la categor√≠a
    await prisma.category.delete({
      where: { id: parseInt(id) }
    });

    logger.info('Category deleted', {
      userId: req.user.id,
      categoryId: category.id,
      categoryName: category.name
    });

    res.json({
      success: true,
      message: 'Categor√≠a eliminada exitosamente'
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/categories/:id/move-tweets
 * Mover todos los tweets de una categor√≠a a otra
 */
router.post('/:id/move-tweets', async (req, res, next) => {
  try {
    const { id } = req.params;
    const { targetCategoryName } = req.body;

    if (!targetCategoryName) {
      throw new AppError('Categor√≠a destino requerida', 400, 'MISSING_TARGET_CATEGORY');
    }

    const sourceCategory = await verifyCategoryOwnership(id, req.user.id);

    // Verificar que la categor√≠a destino existe
    const targetCategory = await prisma.category.findFirst({
      where: {
        name: targetCategoryName,
        userId: req.user.id
      }
    });

    if (!targetCategory) {
      throw new AppError('Categor√≠a destino no encontrada', 404, 'TARGET_CATEGORY_NOT_FOUND');
    }

    // Mover tweets
    const result = await prisma.tweet.updateMany({
      where: {
        userId: req.user.id,
        category: sourceCategory.name,
        isArchived: false
      },
      data: {
        category: targetCategoryName
      }
    });

    logger.info('Tweets moved between categories', {
      userId: req.user.id,
      sourceCategory: sourceCategory.name,
      targetCategory: targetCategoryName,
      movedCount: result.count
    });

    res.json({
      success: true,
      message: `${result.count} tweets movidos exitosamente`,
      movedCount: result.count
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/categories/colors
 * Obtener colores sugeridos para categor√≠as
 */
router.get('/colors', (req, res) => {
  const suggestedColors = [
    { name: 'Azul', value: '#3B82F6' },
    { name: 'Verde', value: '#10B981' },
    { name: 'Rojo', value: '#EF4444' },
    { name: 'Amarillo', value: '#F59E0B' },
    { name: 'P√∫rpura', value: '#8B5CF6' },
    { name: 'Rosa', value: '#EC4899' },
    { name: '√çndigo', value: '#6366F1' },
    { name: 'Gris', value: '#6B7280' },
    { name: 'Naranja', value: '#F97316' },
    { name: 'Teal', value: '#14B8A6' }
  ];

  res.json({ colors: suggestedColors });
});

/**
 * POST /api/v1/categories/auto-create
 * Crear categor√≠as autom√°ticamente usando IA
 */
router.post('/auto-create', async (req, res, next) => {
  try {
    const userId = req.user.id;

    logger.info(`Iniciando creaci√≥n autom√°tica de categor√≠as para usuario ${userId}`);

    const result = await createAutoCategories(userId);

    logger.info('Categor√≠as autom√°ticas creadas:', {
      userId,
      created: result.created,
      categorized: result.categorized,
      totalProcessed: result.totalProcessed
    });

    res.json({
      success: true,
      message: 'Categorizaci√≥n autom√°tica completada',
      result
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/categories/recategorize
 * Recategorizar todos los tweets usando IA
 */
router.post('/recategorize', async (req, res, next) => {
  try {
    const userId = req.user.id;

    logger.info(`Iniciando recategorizaci√≥n de tweets para usuario ${userId}`);

    const result = await recategorizeAllTweets(userId);

    logger.info('Recategorizaci√≥n completada:', {
      userId,
      processed: result.processed,
      updated: result.updated
    });

    res.json({
      success: true,
      message: 'Recategorizaci√≥n completada',
      result
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/categories/suggestions
 * Obtener categor√≠as sugeridas basadas en el historial del usuario
 */
router.get('/suggestions', async (req, res, next) => {
  try {
    const userId = req.user.id;

    const suggestions = await getSuggestedCategories(userId);

    res.json({
      success: true,
      suggestions
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/categories/categorize-uncategorized
 * Categorizar solo tweets que no tienen categor√≠a asignada
 */
router.post('/categorize-uncategorized', async (req, res, next) => {
  try {
    const userId = req.user.id;

    logger.info(`Iniciando categorizaci√≥n de tweets sin categor√≠a para usuario ${userId}`);

    const result = await categorizeUncategorizedTweets(userId);

    logger.info('Categorizaci√≥n de tweets sin categor√≠a completada:', {
      userId,
      found: result.found,
      categorized: result.categorized,
      processed: result.processed
    });

    res.json({
      success: true,
      message: 'Categorizaci√≥n de tweets sin categor√≠a completada',
      result
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/categories/initialize-ai
 * Inicializar el modelo de IA para categorizaci√≥n
 */
router.post('/initialize-ai', async (req, res, next) => {
  try {
    logger.info('Inicializando modelo de IA desde endpoint...');
    
    await initializeAI();

    res.json({
      success: true,
      message: 'Modelo de IA inicializado correctamente'
    });

  } catch (error) {
    next(error);
  }
});

export default router;